import os
import requests
from typing import Dict, Any, List
from datetime import datetime, timedelta
from app import config

GEMINI_API_KEY = config.GEMINI_API_KEY


def _simple_plan_from_prediction(payload: Dict[str, Any]):
    """Fallback deterministic planner: create schedules based on prediction and short-term forecast.
    Expects payload to contain 'prediction' (with liters_required), 'weather' (with forecast list), and optional 'zones'.
    Returns schedules with explicit ISO date fields so frontend can render day-wise plans.
    """
    prediction = payload.get('prediction') or {}
    weather = payload.get('weather') or {}
    liters = 0.0
    if isinstance(prediction, dict):
        try:
            liters = float(prediction.get('liters_required') or prediction.get('liters') or 0.0)
        except Exception:
            liters = 0.0
    # Basic rule: schedule irrigation on days without significant rain, spread across days
    forecast = weather.get('forecast') if isinstance(weather, dict) else []
    schedules = []
    # Plan next 7 days
    days = 7
    # spread into up to 3 irrigation events (or less if small liters)
    max_events = min(3, max(1, int((liters // 500) + 1)))
    per_event_liters = (liters / max_events) if max_events > 0 else 0.0

    scheduled = 0
    from datetime import datetime, timedelta
    for i in range(days):
        # skip days with precipitation chance > 40
        skip = False
        if forecast and i < len(forecast):
            try:
                p = float(forecast[i].get('precipitation') or 0)
                if p >= 40:
                    skip = True
            except Exception:
                pass

        if not skip and scheduled < max_events:
            # schedule time default 06:00 AM
            date_str = (datetime.utcnow() + timedelta(days=i)).strftime('%Y-%m-%d')
            # estimate duration roughly: 1 liter ~ 0.2 minutes per small emitter (very rough)
            estimated_minutes = max(5, int(per_event_liters * 0.02))
            schedules.append({
                'date': date_str,
                'time': '06:00 AM',
                'duration': f'{estimated_minutes} minutes',
                'water_liters': round(per_event_liters, 2),
                'is_enabled': True
            })
            scheduled += 1

    return {'schedules': schedules, 'note': 'generated by fallback planner'}


def generate_day_wise_water_requirements(payload: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Generate day-wise water requirements for the next 7 days based on prediction and weather.
    Returns a list of dicts with 'date', 'water_liters', 'duration_minutes', 'precipitation_percent'.
    """
    prediction = payload.get('prediction') or {}
    weather = payload.get('weather') or {}
    liters = 0.0
    if isinstance(prediction, dict):
        try:
            liters = float(prediction.get('liters_required') or prediction.get('liters') or 0.0)
        except Exception:
            liters = 0.0

    forecast = weather.get('forecast') if isinstance(weather, dict) else []
    day_wise = []
    from datetime import datetime, timedelta
    for i in range(7):
        date_str = (datetime.utcnow() + timedelta(days=i)).strftime('%Y-%m-%d')
        precip_percent = 0
        if forecast and i < len(forecast):
            try:
                precip_percent = float(forecast[i].get('precipitation') or 0)
            except Exception:
                pass

        # Adjust water based on precipitation (reduce if rain expected)
        adjusted_liters = liters * (1 - min(precip_percent / 100.0, 0.8)) / 7  # Spread over 7 days
        duration_minutes = max(5, int(adjusted_liters * 0.02))  # Rough estimate

        day_wise.append({
            'date': date_str,
            'water_liters': round(adjusted_liters, 2),
            'duration_minutes': duration_minutes,
            'precipitation_percent': precip_percent
        })

    return day_wise


def generate_irrigation_plan(payload: Dict[str, Any], user: Any) -> Dict[str, Any]:
    """Generate an irrigation plan using Gemini/Generative API if available, otherwise use a simple planner.
    The function returns a dict with a `schedules` key containing schedule dicts.
    """
    # If no API key, fallback
    if not GEMINI_API_KEY:
        return _simple_plan_from_prediction(payload)

    # Build a prompt for the generative model
    prediction = payload.get('prediction') or {}
    weather = payload.get('weather') or {}
    crop = payload.get('crop_type') or payload.get('crop') or 'unknown'
    soil = payload.get('soil_type') or payload.get('soil') or 'unknown'

    prompt = (
        f"You are an irrigation planner. The user has crop {crop} on soil {soil}. "
        f"Prediction suggests {prediction}. Short forecast: {weather.get('forecast', [])}. "
        f"Create up to 7-day irrigation schedule, avoid days with high chance of rain, split water across days, return JSON with 'schedules' list where each item has time, duration, is_enabled."
    )

    # Call Google Generative or generic endpoint (best-effort). Using REST POST to a hypothetical endpoint.
    try:
        url = os.environ.get('GEN_API_URL') or 'https://generativeapi.example.com/v1/generate'
        headers = {'Authorization': f'Bearer {GEMINI_API_KEY}', 'Content-Type': 'application/json'}
        body = {'prompt': prompt, 'max_tokens': 800}
        resp = requests.post(url, json=body, headers=headers, timeout=10)
        data = resp.json()
        # Expect data['schedules'] as JSON string or structured
        if isinstance(data, dict) and data.get('schedules'):
            return data
        # Try to parse text output
        text = data.get('text') or data.get('output') or ''
        # naive extraction: look for a JSON object in text
        import json, re
        m = re.search(r"\{.*\}", text, re.S)
        if m:
            try:
                return json.loads(m.group(0))
            except Exception:
                pass
        # fallback
        return _simple_plan_from_prediction(payload)
    except Exception:
        return _simple_plan_from_prediction(payload)
